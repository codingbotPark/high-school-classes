# 12.6-------------------------------------------------------------------------------------
# dgsw.goorm.io 14번문제
a = input()
b = []
for i in range(len(a)):
	if 48 < ord(a[i]) < 57:
		b.append(int(a[i]))
print(int(''.join(map(str,b))) + 5)

#-----------

# 자료구조 수행평가

# 음수와 양수를 스택 형식으로 정렬 (-1 2 4 5 -2  =>  -1 -2 2 4 5)
a = list(map(int,input().split()))
b = []
c = []
for i in range(len(a)):
    if a[i] < 0:
        # b[i] = a[i]
        b.append(a[i])
    else:
        c.append(a[i])
print(*(b + c))

# 문자열이 입력되고 각 문자가 얼마나 사용되었는지 출력
# mmaaabbbb  =>  m2a3b4
a = list(input())
counter = 1
i = 0
for i in range(len(a)-1):
    if (a[i] != a[i+1]):
        print(f'{a[i]}{counter}',end='')
        counter= 1
    else:
        counter += 1
print(f'{a[i+1]}{counter}',end='')

# 입력된 회수만큼 1부터 홀수의 합을 더한다
# 2 => 1 + 3 = 4
a = int(input())
j = 0
for i in range(1,a+1,2):
    print(i)
    j += i
print(j)

# 자신의 약수로 이루어 졌고 1 부터 n까지의 수를 한다
# 완전수 구하기
a = int(input())
for i in range(1,a):
    k = 0
    for j in range(1,i):
        if i % j == 0:
            k+=j 
    if k == i:
        print(i)

# 12.9-------------------------------------------------------------------------------------

# 자료구조 기말고사 대비

# ----트리와 그래프의 차이----
# 그래프 = 노드와 노드를 연결하는 간선으로 모아 놓은 자료구조
# => 사이클이 있든 없든 그래프
# 트리 = 그래프의 한 종류로 방향성이 있는 비순환 그래프의 한 종류
# => 사이클이 없어야 한다


# ----트리에 대한 용어----
# 트리는 계층적 관계를 표현

# 노드 | 트리를 구성하는 각각의 요소
# 간선 | 노드간의 연결 선
# 루트 노드 | 트리 구조에 최상에 있는 노드

# 단말 노드, 잎노드 | 하위에 다른 노드가 연결되어 있지 않는 최하위 노드
# 내부 노드, 비단말 노드 | 단말 노드를 제외한 모든 노드

# 서브트리 | 루트의 다음 레벨이 있는 노드들은 서브트리의 루트가 된다
# 자식 노드 | 노드 x의 서브 트리의 루트들은 x의 자식
# 부모 노드 | x는 그 자식들의 부모
# 형제 노드 | 부모가 같은 자식노드들
# 조상 노드 | 루트로부터 노드에 이르는 경로상의 모든 노드들
# 트리의 차수 | 트리에 속한 노드의 최대 차수


# ----DFS와 BFS----
# DFS = 깊이 우선 탐색(스택)
#
# 진행방향 (1 -> 2 -> 3 -> 4 -> 5 -> 6)
#           |1|
#           /  \
#        |2|    |5|
#        / \      \
#      |3| |4|     |6|

# BFS = 너비 우선 탐색(큐)
#
# 진행방향 (1 -> 2 -> 3 -> 4 -> 5 -> 6)
#           |1|
#           /  \
#        |2|    |3|
#        / \      \
#      |4| |5|     |6|

# 트리나 그래프를 인접 리스트(중요도에 따라 나타내기) or 인접 행렬로 표현


# ----신장트리와 prim, kruskal----
# 신장 트리 | 그래프의 모든 정점들이 연결, 사이클이 없는 트리
# 
# 그래프가 주어졌을 때 여러 신장 트리 중 최소비용을 구하는 알고리즘
# = 프림(prim), 크루스칼(kruskal)
# 
# 크루스칼(kruskal)
# 간선에 따른 가중치에 대한 표를 만들고
# 신장 크리를 만들어서
# 출발 노드가 필요없이
# 최소비용 신장트리를 만들 수 있다
# => 어디에서 시작하나 같다
# 
# 
# 프림(prim)
# 시작 노드가 주어지고
# 지나온 길과 이어진 엣지들의 가중치를 낮은 순으로 진입한다
# 
# 지나온 길을과 이어진 엣지들의 가중치를 비교하기 때문에
# 최소비용 신장트리를 구할 수 있다


# ----완전 이진 트리와 포화 이진 트리----
# 완전 이진 트리 | 가각의 노드가 최대 2개의 노드를 가지는 트리의 자료구조
# 포화 이진 트리 | 모든 잎의 레벨이 동일한 이진트리,
#                 잎이 아닌 내부 노드들을 모두 2개의 자식을 가지는 트리
#
# 완전이진트리는 포화 이진 트리의 leaf들을 오른쪽에서 n개제거하여 얻어진 트리
# 즉 포화 이진 트리도 완전 이진 트리이다
#
# 완전 이진 트리 (인덱스로 나타냄)
# 
#           |1|
#           /  \
#        |2|    |3|
#        / \    / 
#      |4| |5| |6|
#
#
#           |1|
#           /  \
#        |2|    |3|
#        / \   
#      |4| |5| 
# 
# 완전 이진 트리는 배열로 나타낼 수 있기 때문에 속도가 더 빠르다
# 예) 인덱스 4의 부모 노드는 4 / 2 = 2
# 
# 포화 이진 트리
#           |1|
#           /  \
#        |2|    |3|
#        / \    / \
#      |4| |5| |6| |7|
#
#

# 편향 이진 트리 | 같은 높이의 이진 트리 중 최소 개수의 노드,
#                 왼쪽 혹은 오른쪽 서브트리 만을 가지는 이진트리
# 
#           |1|
#           / 
#        |2|   
#        / 
#      |4|